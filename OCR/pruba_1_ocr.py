# -*- coding: utf-8 -*-
"""Pruba_1_OCR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RuHtwgR9foLC6PoShCxrDqSqtbxQLGzr

# **Preparación del espacio de trabajo**
"""

import os
from PIL import Image
import pytesseract
import sys
from pdf2image import convert_from_path
import os
import numpy as np
import cv2
import matplotlib.pyplot as plt
# Para poder visualizar la imagen en colab
# from google.colab.patches import cv2_imshow

#Funciones para procesar la imagen
# get grayscale image
def get_grayscale(image):
    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# noise removal
def remove_noise(image):
    return cv2.medianBlur(image,5)

#thresholding
def thresholding(image):
    return cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]

#dilation
def dilate(image):
    kernel = np.ones((5,5),np.uint8)
    return cv2.dilate(image, kernel, iterations = 1)

#erosion
def erode(image):
    kernel = np.ones((5,5),np.uint8)
    return cv2.erode(image, kernel, iterations =1)

#opening - erosion followed by dilation
def opening(image):
    kernel = np.ones((5,5),np.uint8)
    return cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel)

#canny edge detection
def canny(image):
    return cv2.Canny(image, 100, 200)

#skew correction
def deskew(image):
  coords = np.column_stack(np.where(image > 0))
  angle = cv2.minAreaRect(coords)[-1]
  if angle < -45:
    angle = -(90 + angle)
  else:
    angle = -angle
    (h, w) = image.shape[:2]
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    rotated = cv2.warpAffine(image, M, (w, h), flags=cv2.INTER_CUBIC, borderMode=cv2.BORDER_REPLICATE)
    return rotated

#template matching
def match_template(image, template):
    return cv2.matchTemplate(image, template, cv2.TM_CCOEFF_NORMED)


if __name__ == '__main__':

    # Muestra el directorio de trabajo
    dir = os.getcwd()
    print(dir)
    os.listdir(dir)
    pytesseract.pytesseract.tesseract_cmd= 'C:/Program Files/Tesseract-OCR/tesseract.exe'
    # Muestra los archivos de la carpeta
    os.listdir()
    # Path de el pdf
    PDF_file = "Prueba6.pdf"
    """Parte 1 convertir el PDF a imagenes"""
    # Alamacena todas las paginas del pdf en una variable
    pages = convert_from_path("D:/BACKUP/Steffanini/pruba_1_ocr/"+PDF_file, 500)
    pages
    # Contador para almacenar imágenes de cada página de PDF a imagen
    image_counter = 1
    # Iterar a través de todas las páginas almacenadas arriba
    for page in pages:
        filename = "page_"+str(image_counter)+".jpg"
        # Guarda la imagen de la pagina en el sistema
        page.save(filename, 'JPEG')
        # Incrementa el contador para actualizar el nombre del archivo
        image_counter = image_counter + 1
    # Variable para obtener el recuento del número total de páginas
    filelimit = image_counter-1
    """Parte 2 Creacion del archivo de texto donde se almacena la informacion"""
    # Creación de un archivo de texto para escribir la salida
    outfile = "out_text.txt"
    # Abre el archivo en modo agregar para que todos los contenidos de todas las imágenes se agregan al mismo archivo
    f = open(outfile, "a")





    # Lee la imagen
    img = cv2.imread("page_1.jpg")

    #Imagen original
    # cv2_imshow(img)

    #Pasamos la imagen original a escala de grises
    gray = get_grayscale(img)
    # cv2_imshow(gray)

    erode = erode(gray)
    # cv2_imshow(erode)

    #Aclaramos la imagen
    #dilate = dilate(erode)
    #cv2_imshow(dilate)

    media = np.mean(erode)
    media

    var =np.var(erode)
    var

    desv =np.std(erode)
    desv

    #Calculo interpolacion
    x = np.array([24.49,49.65,59.03,89.94])
    y = np.array([120.,50.,45.,10.])
    pol = np.polyfit(x,y,len(x)-1)  # coeficientes del polinomio
    d = 5
    xx = np.linspace(min(x),max(x))
    yy = np.polyval(pol,xx)

    plt.plot(xx, yy, '-',x, y, 'ro')
    plt.axis([min(xx)-d, max(xx)+d, min(yy)-d, max(yy)+d]);

    val = np.polyval(pol,desv)
    val

    #Eliminamos ruido de la imagen
    #noise = remove_noise(erode)
    #cv2_imshow(noise)

    #umbral, imageMet = cv2.threshold(dilate, 0, 255, cv2.THRESH_OTSU)
    umbral = np.polyval(pol,desv)
    mascara = np.uint8((erode>umbral)*255)

    #cv2_imshow(imageMet)

    # cv2_imshow(mascara)

    bin = thresholding(erode)
    # cv2_imshow(bin)

    #resize = cv2.resize(bin,(300, 400))
    cv2.imwrite('pageL_1.jpg',mascara)

    """Parte 4 Reconocimiento de texto de las imagenes usando OCR"""

    # Configuracion adicional del ocr
    custom_config = r'--oem 3'

    # Iterar de 1 al número total de páginas
    for i in range(1, filelimit + 1):

        # Set filename to recognize text from
        # Again, these files will be:
        # page_1.jpg
        # page_2.jpg
        # ....
        # page_n.jpg
        filename = "pageL_"+str(i)+".jpg"

        # Recognize the text as string in image using pytesserct
        text = pytesseract.image_to_string(Image.open(filename),config=custom_config)


        # The recognized text is stored in variable text
        # Any string processing may be applied on text
        # Here, basic formatting has been done:
        # In many PDFs, at line ending, if a word can't
        # be written fully, a 'hyphen' is added.
        # The rest of the word is written in the next line
        # Eg: This is a sample text this word here GeeksF-
        # orGeeks is half on first line, remaining on next.
        # To remove this, we replace every '-\n' to ''.
        text = text.replace('-\n', '')

        # Finalmente, escribe el texto procesado en el archivo.
        f.write(text)

    # Cierre el archivo después de escribir todo el texto.
    f.close()
